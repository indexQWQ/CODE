#include <stdio.h>

// 整型提升的意义：
// 表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度
// 一般就是int的字节长度，同时也是CPU的通用寄存器的长度。
// 因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长
// 度。
// 通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令
// 中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转
// 换为int或unsigned int，然后才能送入CPU去执行运算。

// //负数的整形提升
// char c1 = -1;
// 变量c1的二进制位(补码)中只有8个比特位：
// 1111111
// 因为 char 为有符号的 char
// 所以整形提升的时候，高位补充符号位，即为1

// 提升之后的结果是：
// 111111111111111111111111 11111111
// //正数的整形提升
// char c2 = 1;
// 变量c2的二进制位(补码)中只有8个比特位：
// 00000001
// 因为 char 为有符号的 char
// 所以整形提升的时候，高位补充符号位，即为0
// 提升之后的结果是：
// 00000000000000000000000000000001

//无符号整形提升，高位补0

// int main()
// {
//     char c=5;
//     //补码00000101 -c
//     //补码000000000000000000000000 00000101
//     char b=126;
//     //补码01111110 -b
//     //补码000000000000000000000000 01111110
//     char a=b+c;//要将char类型转换为int类型才能参与计算->整型提升
//     //补码000000000000000000000000 00000101 -c 整型提升
//     //补码000000000000000000000000 01111110 -b 整型提升
//     //运算000000000000000000000000 10000011 
//     //补码10000011 -a
//     printf("%d\n",a);
//     //补码10000011 -a
//     //补码111111111111111111111111 10000011 -a 整型提升
//     //反码111111111111111111111111 10000010
//     //原码100000000000000000000000 01111101 -> -125
//     //printf("%c\n",a);
//     return 0;
// }
// //结果-125

//例1
// int main()
// {
//     unsigned char a = 0xb6;//10110110
//     short b = 0xb600;
//     int c = 0xb6000000;
//     if(a==0xb6)//整型提升
//     printf("a");

//     if(b==0xb600)//整型提升
//     printf("b");
    
//     if(c==0xb6000000)//没有整型提升
//     printf("c");
    
//     return 0;
// }

//例二
// int main()
// {
//  char c = 1;
//  printf("%u\n", sizeof(c));//1
//  printf("%u\n", sizeof(+c));//4
//  printf("%u\n", sizeof(-c));//4
//  return 0;
// }

