#include <stdio.h>
#include <stddef.h>
// 结构体内存对齐
// 我们已经掌握了结构体的基本使用了。
// 现在我们深入讨论一个问题：计算结构体的大小。
// 这也是一个特别热门的考点：结构体内存对齐

// 如何计算？
// 首先得掌握结构体的对齐规则：
// 1. 第一个成员在与结构体变量偏移量为0的地址处。
// 2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
// 对齐数 = 编译器默认的一个对齐数 与 该成员大小 的较小值。VS中默认的值为8,其他编译器上没有默认对齐数
// 3. 结构体总大小为##最大对齐数（每个成员变量都有一个对齐数##的整数倍。
// 4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整
// 体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。
// offsetof(type,member)-->宏(macro) 返回的是一个偏移量
// //练习1
// struct S1
// {
//     char c1;
//     int i;
//     char c2;
// };
// //练习2
// struct S2
// {
//     char c1;
//     char c2;
//     int i;
// };
// struct S3
// {
//     double d;
//     char c;
//     int i;
// };//16
// struct s4
// {
//     char c1;
//     struct S3 s3;
//     double d;
// };//32 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整
// // 体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。所以如果d的类型是int的话结果也是32
// int main()
// {
//     // printf("%d\n", sizeof(struct S1));//12
//     // printf("%d\n", sizeof(struct S2));//8
//     // printf("%d\n", (int)offsetof(struct S1,c1));
//     // printf("%d\n", (int)offsetof(struct S1,i));
//     // printf("%d\n", (int)offsetof(struct S1,c2));
//     printf("%d\n",(int)sizeof(struct s4));
//     return 0;
// }
// 为什么存在内存对齐?
// 大部分的参考资料都是如是说的：
// 1. 平台原因(移植原因)：
// 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特
// 定类型的数据，否则抛出硬件异常。
// 2. 性能原因：
// 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。
// 原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。
// 例如：
// struct S
// {
//     char c;
//     int i;
// };
// 如果是32位机器的话，一次可以读取4个字节，但是如果没有内存对齐规则的话要想读取i就需要读取两次
// 总体来说：
// 结构体的内存对齐是拿空间来换取时间的做法。
// 那在设计结构体的时候，我们既要满足对齐，又要节省空间，如何做到：
// 让占用空间小的成员尽量集中在一起。

// 修改默认对齐数
// 之前我们见过了#pragma 这个预处理指令，这里我们再次使用，可以改变我们的默认对齐数。
// #pragma once 头文件中使用，防止头文件被多次引用
#pragma pack(4)
struct S
{
    int i;
    double d;
};
#pragma pack()
int main()
{
    printf("%d\n",(int)sizeof(struct S));//没改前16 改后12
    return 0;
}
