两个相邻的操作符先执行哪个取决于他们的优先级，若优先级相同，则根据结合性决定先执行哪个。



一些问题表达式
注释：代码1在计算的时候，由于*比+的优先级高，只能保证，*的计算是比+早，但是优先级并不
能决定第三个*比第一个+早执行。
所以表达式的计算机顺序就可能是：
//表达式的求值部分由操作符的优先级决定。
//表达式1
a*b + c*d + e*f
a*b
c*d
a*b + c*d
e*f
a*b + c*d + e*f


或者：
a*b
c*d
e*f
a*b + c*d
a*b + c*d + e*f


//代码3-非法表达式
int main()
{
 int i = 10;
 i = i-- - --i * ( i = -3 ) * i++ + ++i;
 printf("i = %d\n", i);
 return 0;
}


//代码4
int fun()
{
     static int count = 1;
     return ++count;
}
int main()
{
     int answer;
     answer = fun() - fun() * fun();
     printf( "%d\n", answer);//输出多少？
     return 0;
}
这个代码有没有实际的问题？
有问题！
虽然在大多数的编译器上求得结果都是相同的。
但是上述代码 answer = fun() - fun() * fun(); 中我们只能通过操作符的优先级得知：先算乘法，
再算减法。
函数的调用先后顺序无法通过操作符的优先级确定。

//代码5
#include <stdio.h>
int main()
{
 int i = 1;
 int ret = (++i) + (++i) + (++i);
 printf("%d\n", ret);
 printf("%d\n", i);
 return 0;
}
linux下编译运行结果：
10
4

VS2013下编译运行结果：
12
4   

//尝试在linux 环境gcc编译器，VS2013环境下都执行，看结果
看看同样的代码产生了不同的结果，这是为什么？
简单看一下汇编代码.就可以分析清楚.
这段代码中的第一个 + 在执行的时候，第三个++是否执行，这个是不确定的，因为依靠操作符的优先级
和结合性是无法决定第一个 + 和第
三个前置 ++ 的先后顺序。

总结：我们写出的表达式如果不能通过操作符的属性确定唯一的计算路径，那这个表达式就是存在问题
的。

